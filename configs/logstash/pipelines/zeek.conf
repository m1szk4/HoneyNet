# Logstash Pipeline for Zeek (Bro)

input {
  file {
    path => "/input/zeek/conn.log"
    codec => plain
    type => "zeek_conn"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_zeek"
  }
}

filter {
  # Skip comments and empty lines
  if [message] =~ /^#/ or [message] == "" {
    drop { }
  }
  
  # Parse TSV format
  csv {
    separator => "	"  # Tab character
    columns => ["ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", 
                "proto", "service", "duration", "orig_bytes", "resp_bytes", 
                "conn_state", "local_orig", "local_resp", "missed_bytes", 
                "history", "orig_pkts", "orig_ip_bytes", "resp_pkts", "resp_ip_bytes"]
  }
  
  # Parse timestamp
  date {
    match => ["ts", "UNIX"]
    target => "@timestamp"
  }
  
  # Anonymize source IP
  ruby {
    code => '
      require "openssl"
      salt = ENV["SALT_SECRET"] || "default_salt_change_me"
      src_ip = event.get("id.orig_h")
      if src_ip
        hash = OpenSSL::HMAC.hexdigest("SHA256", salt, src_ip)
        event.set("source_ip_anon", hash)
      end
    '
  }
  
  # GeoIP enrichment
  if [id.orig_h] {
    geoip {
      source => "id.orig_h"
      target => "geoip"
      fields => ["country_code2"]
      tag_on_failure => ["_geoip_lookup_failure"]
    }
    
    if [geoip][country_code2] {
      mutate {
        add_field => { "country_code" => "%{[geoip][country_code2]}" }
      }
    }
  }
  
  # Rename fields
  mutate {
    rename => {
      "id.orig_p" => "source_port"
      "id.resp_h" => "dest_ip"
      "id.resp_p" => "dest_port"
      "uid" => "session_id"
    }
    add_field => {
      "event_type" => "zeek_conn"
      "honeypot_name" => "zeek"
    }
  }
  
  # Convert types
  mutate {
    convert => {
      "source_port" => "integer"
      "dest_port" => "integer"
      "duration" => "float"
      "orig_bytes" => "integer"
      "resp_bytes" => "integer"
    }
  }
  
  # Calculate payload size
  ruby {
    code => '
      orig = event.get("orig_bytes") || 0
      resp = event.get("resp_bytes") || 0
      event.set("payload_size", orig + resp)
    '
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => ["id.orig_h", "message", "path", "host", "geoip", "ts", 
                     "local_orig", "local_resp", "missed_bytes"]
  }
}

output {
  http {
    url => "http://clickhouse:8123/?query=INSER